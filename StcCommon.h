/*
 * Copyright 2020 Lag Free Games, LLC
 * All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sub license, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial portions
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
 * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
 * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#pragma once

#include <assert.h>
#include <intrin.h>
#include <inttypes.h>
#include <stdbool.h>
#include <stdint.h>

#ifndef COBJMACROS
#define COBJMACROS 1
#endif
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 1
#endif
#pragma warning(push)
#pragma warning(disable : 4061)
#pragma warning(disable : 4201)
#pragma warning(disable : 4255)
#pragma warning(disable : 4365)
#pragma warning(disable : 4820)
#pragma warning(disable : 5039)
#pragma warning(disable : 26812)
#include <stdio.h>
#include <d3d11_4.h>
#include <d3d11on12.h>
#include <VersionHelpers.h>
#pragma warning(pop)

#ifdef __cplusplus
extern "C" {
#endif

typedef enum StcServerStatus {
    STC_SERVER_STATUS_SUCCESS = 0,
    STC_SERVER_STATUS_FAIL_CREATE_EVENT = -0X74000000,
    STC_SERVER_STATUS_FAIL_STRING_FORMAT,
    STC_SERVER_STATUS_FAIL_CREATE_GLOBAL_FILE_MAPPING,
    STC_SERVER_STATUS_FAIL_MAP_GLOBAL_INFO,
    STC_SERVER_STATUS_FAIL_CREATE_CONNECTION_FILE_MAPPING,
    STC_SERVER_STATUS_FAIL_MAP_CONNECTION_INFO,
    STC_SERVER_STATUS_FAIL_DISCONNECTED,
    STC_SERVER_STATUS_FAIL_CONNECT_IN_PROGRESS,
    STC_SERVER_STATUS_FAIL_NO_FRAMES_AVAIALBLE,
    STC_SERVER_STATUS_FAIL_TICK,
    STC_SERVER_STATUS_FAIL_WAIT_CLIENT_READ,
    STC_SERVER_STATUS_FAIL_SIGNAL_WRITE,
    STC_SERVER_STATUS_MAX_ENUM = 0x7FFFFFFF,
} StcServerStatus;

typedef enum StcClientStatus {
    STC_CLIENT_STATUS_SUCCESS = 0,
    STC_CLIENT_STATUS_FAIL_QUERY_DEVICE1 = -0X72000000,
    STC_CLIENT_STATUS_FAIL_CREATE_EVENT,
    STC_CLIENT_STATUS_FAIL_OUT_OF_MEMORY,
    STC_CLIENT_STATUS_FAIL_QUERY_SID,
    STC_CLIENT_STATUS_FAIL_CONVERT_SID_TO_STRING,
    STC_CLIENT_STATUS_FAIL_STRING_FORMAT,
    STC_CLIENT_STATUS_FAIL_OPEN_GLOBAL_FILE_MAPPING,
    STC_CLIENT_STATUS_FAIL_MAP_GLOBAL_INFO,
    STC_CLIENT_STATUS_FAIL_VERSION_MISMATCH,
    STC_CLIENT_STATUS_FAIL_CONNECTION_UNAVAILABLE,
    STC_CLIENT_STATUS_FAIL_OPEN_CONNECTION_FILE_MAPPING,
    STC_CLIENT_STATUS_FAIL_MAP_CONNECTION_INFO,
    STC_CLIENT_STATUS_FAIL_OPEN_PROCESS,
    STC_CLIENT_STATUS_FAIL_NOT_CONNECTED,
    STC_CLIENT_STATUS_FAIL_DISCONNECTED,
    STC_CLIENT_STATUS_FAIL_TICK,
    STC_CLIENT_STATUS_FAIL_WAIT_SERVER_WRITE,
    STC_CLIENT_STATUS_FAIL_SIGNAL_READ,
    STC_CLIENT_STATUS_MAX_ENUM = 0x7FFFFFFF,
} StcClientStatus;

typedef enum StcServerStopReason {
    STC_SERVER_STOP_REASON_NONE,
    STC_SERVER_STOP_REASON_DESTROY,
    STC_SERVER_STOP_REASON_CLIENT_REQUESTED,
    STC_SERVER_STOP_REASON_CLIENT_TIMED_OUT,
    STC_SERVER_STOP_REASON_MISSING_11_TO_12_SUPPORT,
    STC_SERVER_STOP_REASON_MISSING_12_TO_11_SUPPORT,
    STC_SERVER_STOP_REASON_FAIL_CREATE_COMPATIBILITY_TEXTURE,
    STC_SERVER_STOP_REASON_FAIL_CREATE_WRAPPED_RESOURCE,
    STC_SERVER_STOP_REASON_FAIL_QUERY_DXGI_RESOURCE1,
    STC_SERVER_STOP_REASON_FAIL_CREATE_SHARED_HANDLE,
    STC_SERVER_STOP_REASON_FAIL_OPEN_SHARED_HANDLE,
    STC_SERVER_STOP_REASON_FAIL_CREATE_TEXTURE_11,
    STC_SERVER_STOP_REASON_FAIL_CREATE_TEXTURE_12,
    STC_SERVER_STOP_REASON_FAIL_QUERY_KEYED_MUTEX,
    STC_SERVER_STOP_REASON_FAIL_QUERY_DXGI_RESOURCE,
    STC_SERVER_STOP_REASON_FAIL_GET_SHARED_HANDLE,
    STC_SERVER_STOP_REASON_FAIL_CREATE_FENCE,
    STC_SERVER_STOP_REASON_FAIL_D3D11_QUEUE_WAIT,
    STC_SERVER_STOP_REASON_FAIL_D3D12_QUEUE_WAIT,
    STC_SERVER_STOP_REASON_FAIL_D3D11_QUEUE_SIGNAL,
    STC_SERVER_STOP_REASON_FAIL_D3D12_QUEUE_SIGNAL,
    STC_SERVER_STOP_REASON_FAIL_D3D11_ACQUIRE_KEYED_MUTEX_TO_INITIALIZE,
    STC_SERVER_STOP_REASON_FAIL_D3D11_RELEASE_KEYED_MUTEX_TO_INITIALIZE,
    STC_SERVER_STOP_REASON_FAIL_D3D12_ACQUIRE_KEYED_MUTEX_TO_INITIALIZE,
    STC_SERVER_STOP_REASON_FAIL_D3D12_RELEASE_KEYED_MUTEX_TO_INITIALIZE,
    STC_SERVER_STOP_REASON_FAIL_D3D11_ACQUIRE_KEYED_MUTEX_TO_OWN,
    STC_SERVER_STOP_REASON_FAIL_D3D11_RELEASE_KEYED_MUTEX_TO_OWN,
    STC_SERVER_STOP_REASON_FAIL_D3D12_ACQUIRE_KEYED_MUTEX_TO_OWN,
    STC_SERVER_STOP_REASON_FAIL_D3D12_RELEASE_KEYED_MUTEX_TO_OWN,
    STC_SERVER_STOP_REASON_FAIL_D3D11_ACQUIRE_KEYED_MUTEX_TO_WRITE,
    STC_SERVER_STOP_REASON_FAIL_D3D12_ACQUIRE_KEYED_MUTEX_TO_WRITE,
    STC_SERVER_STOP_REASON_FAIL_D3D11_RELEASE_KEYED_MUTEX_TO_WRITE,
    STC_SERVER_STOP_REASON_FAIL_D3D12_RELEASE_KEYED_MUTEX_TO_WRITE,
    STC_SERVER_STOP_REASON_FAIL_D3D11_USER_CREATE_FRAME_CALLBACK,
    STC_SERVER_STOP_REASON_FAIL_D3D12_USER_CREATE_FRAME_CALLBACK,
    STC_SERVER_STOP_REASON_MAX_ENUM = 0x7FFFFFFF,
} StcServerStopReason;

typedef enum StcClientStopReason {
    STC_CLIENT_STOP_REASON_NONE,
    STC_CLIENT_STOP_REASON_DESTROY,
    STC_CLIENT_STOP_REASON_NEW_CONNECTION,
    STC_CLIENT_STOP_REASON_SERVER_REQUESTED,
    STC_CLIENT_STOP_REASON_SERVER_TIMED_OUT,
    STC_CLIENT_STOP_REASON_FAIL_OPEN_SHARED_D3D11_TEXTURE,
    STC_CLIENT_STOP_REASON_FAIL_OPEN_SHARED_D3D11_TEXTURE_LEGACY,
    STC_CLIENT_STOP_REASON_FAIL_OPEN_SHARED_D3D12_TEXTURE,
    STC_CLIENT_STOP_REASON_FAIL_OPEN_SHARED_D3D12_WRITE_FENCE,
    STC_CLIENT_STOP_REASON_FAIL_OPEN_SHARED_D3D12_READ_FENCE,
    STC_CLIENT_STOP_REASON_FAIL_DUPLICATE_HANDLE,
    STC_CLIENT_STOP_REASON_FAIL_QUERY_KEYED_MUTEX,
    STC_CLIENT_STOP_REASON_FAIL_D3D11_ACQUIRE_SYNC,
    STC_CLIENT_STOP_REASON_FAIL_D3D11_RELEASE_SYNC,
    STC_CLIENT_STOP_REASON_FAIL_D3D12_QUEUE_WAIT,
    STC_CLIENT_STOP_REASON_FAIL_D3D12_QUEUE_SIGNAL,
    STC_CLIENT_STOP_REASON_FAIL_D3D11_USER_OPEN_FRAME_CALLBACK,
    STC_CLIENT_STOP_REASON_FAIL_D3D12_USER_OPEN_FRAME_CALLBACK,
    STC_CLIENT_STOP_REASON_MAX_ENUM = 0x7FFFFFFF,
} StcClientStopReason;

typedef enum StcSrgbChannelType {
    STC_SRGB_CHANNEL_TYPE_UNORM,
    STC_SRGB_CHANNEL_TYPE_UNORM_SRGB,
    STC_SRGB_CHANNEL_TYPE_TYPELESS,
    STC_SRGB_CHANNEL_TYPE_MAX_ENUM = 0x7FFFFFFF,
} StcSrgbChannelType;

typedef enum StcApi {
    STC_API_D3D11,
    STC_API_D3D12,
    STC_API_MAX_ENUM = 0x7FFFFFFF,
} StcApi;

typedef enum StcBindFlagBits {
    STC_BIND_FLAG_NONE = 0x00000000,
    STC_BIND_FLAG_SHADER_RESOURCE = 0x00000008,
    STC_BIND_FLAG_RENDER_TARGET = 0x00000020,
    STC_BIND_FLAG_UNORDERED_ACCESS = 0x00000080,
    STC_BIND_FLAG_MAX_ENUM = 0x7FFFFFFF,
} StcBindFlagBits;
typedef uint32_t StcBindFlags;

typedef enum StcMessageCategory {
    STC_MESSAGE_CATEGORY_SERVER_CREATE,
    STC_MESSAGE_CATEGORY_SERVER_DESTROY,
    STC_MESSAGE_CATEGORY_SERVER_OPEN,
    STC_MESSAGE_CATEGORY_SERVER_RESET,
    STC_MESSAGE_CATEGORY_SERVER_TICK,
    STC_MESSAGE_CATEGORY_SERVER_FRAME_CREATE,
    STC_MESSAGE_CATEGORY_SERVER_WAIT,
    STC_MESSAGE_CATEGORY_SERVER_SIGNAL,
    STC_MESSAGE_CATEGORY_CLIENT_CREATE,
    STC_MESSAGE_CATEGORY_CLIENT_DESTROY,
    STC_MESSAGE_CATEGORY_CLIENT_FRAME_OPEN,
} StcMessageCategory;

typedef enum StcMessageSeverity {
    STC_MESSAGE_SEVERITY_ERROR,
    STC_MESSAGE_SEVERITY_WARNING,
    STC_MESSAGE_SEVERITY_INFO,
} StcMessageSeverity;

typedef enum StcMessageId {
    STC_MESSAGE_ID_SERVER_VERSION,
    STC_MESSAGE_ID_SERVER_FAIL_GLOBAL_STRING_FORMAT,
    STC_MESSAGE_ID_SERVER_FAIL_CREATE_GLOBAL_FILE_MAPPING,
    STC_MESSAGE_ID_SERVER_FAIL_MAP_GLOBAL_INFO,
    STC_MESSAGE_ID_SERVER_FAIL_12_FOR_11_LOADLIBRARY_D3D12,
    STC_MESSAGE_ID_SERVER_FAIL_12_FOR_11_GETMODULEHANDLE_D3D11,
    STC_MESSAGE_ID_SERVER_FAIL_12_FOR_11_GETPROCADDRESS_D3D12CREATEDEVICE,
    STC_MESSAGE_ID_SERVER_FAIL_12_FOR_11_GETPROCADDRESS_D3D11ON12CREATEDEVICE,
    STC_MESSAGE_ID_SERVER_FAIL_12_FOR_11_QUERYINTERFACE_ID3D11DEVICE5,
    STC_MESSAGE_ID_SERVER_FAIL_12_FOR_11_QUERYINTERFACE_ID3D11DEVICECONTEXT4,
    STC_MESSAGE_ID_SERVER_FAIL_12_FOR_11_QUERYINTERFACE_IDXGIDEVICE,
    STC_MESSAGE_ID_SERVER_FAIL_12_FOR_11_GETADAPTER,
    STC_MESSAGE_ID_SERVER_FAIL_12_FOR_11_D3D12CREATEDEVICE,
    STC_MESSAGE_ID_SERVER_FAIL_12_FOR_11_D3D11ON12CREATEDEVICE,
    STC_MESSAGE_ID_SERVER_FAIL_12_FOR_11_QUERYINTERFACE_ID3D11ON12DEVICE,
    STC_MESSAGE_ID_SERVER_D3D12_CLIENT_ALLOWED,
    STC_MESSAGE_ID_SERVER_CREATE_D3D11_SUCCESS,
    STC_MESSAGE_ID_SERVER_FAIL_11_FOR_12_LOADLIBRARY_D3D11,
    STC_MESSAGE_ID_SERVER_FAIL_11_FOR_12_GETPROCADDRESS_D3D11ON12CREATEDEVICE,
    STC_MESSAGE_ID_SERVER_FAIL_11_FOR_12_D3D11ON12CREATEDEVICE,
    STC_MESSAGE_ID_SERVER_FAIL_11_FOR_12_QUERYINTERFACE_ID3D11ON12DEVICE,
    STC_MESSAGE_ID_SERVER_FAIL_11_FOR_12_QUERYINTERFACE_ID3D12COMPATIBILITYDEVICE,
    STC_MESSAGE_ID_SERVER_D3D11_CLIENT_ALLOWED,
    STC_MESSAGE_ID_SERVER_FAIL_CREATE_FENCE_EVENT,
    STC_MESSAGE_ID_SERVER_CREATE_D3D12_SUCCESS,
    STC_MESSAGE_ID_SERVER_DESTROY_D3D11_SUCCESS,
    STC_MESSAGE_ID_SERVER_DESTROY_D3D12_SUCCESS,
    STC_MESSAGE_ID_SERVER_FAIL_CONNECTION_STRING_FORMAT,
    STC_MESSAGE_ID_SERVER_FAIL_CREATE_CONNECTION_FILE_MAPPING,
    STC_MESSAGE_ID_SERVER_FAIL_MAP_CONNECTION_INFO,
    STC_MESSAGE_ID_SERVER_CONNECTION_READY,
    STC_MESSAGE_ID_SERVER_D3D11_CONNECTION_RESET,
    STC_MESSAGE_ID_SERVER_D3D12_CONNECTION_RESET,
    STC_MESSAGE_ID_SERVER_RECOVER_FROM_OPEN_FAILURE,
    STC_MESSAGE_ID_SERVER_CONNECT_TOKEN_TAKEN,
    STC_MESSAGE_ID_SERVER_CONNECT_HANDSHAKE_COMPLETE,
    STC_MESSAGE_ID_SERVER_CLIENT_REQUEST_STOP,
    STC_MESSAGE_ID_SERVER_CLIENT_TIMEOUT,
    STC_MESSAGE_ID_SERVER_CLIENT_TIMEOUT_HANDSHAKE,
    STC_MESSAGE_ID_SERVER_FAIL_D3D11_ACQUIRE_KEYED_MUTEX_TO_INITIALIZE,
    STC_MESSAGE_ID_SERVER_FAIL_D3D11_RELEASE_KEYED_MUTEX_TO_INITIALIZE,
    STC_MESSAGE_ID_SERVER_FAIL_D3D12_ACQUIRE_KEYED_MUTEX_TO_INITIALIZE,
    STC_MESSAGE_ID_SERVER_FAIL_D3D12_RELEASE_KEYED_MUTEX_TO_INITIALIZE,
    STC_MESSAGE_ID_SERVER_FAIL_D3D11_ACQUIRE_KEYED_MUTEX_TO_OWN,
    STC_MESSAGE_ID_SERVER_FAIL_D3D11_RELEASE_KEYED_MUTEX_TO_OWN,
    STC_MESSAGE_ID_SERVER_FAIL_D3D12_ACQUIRE_KEYED_MUTEX_TO_OWN,
    STC_MESSAGE_ID_SERVER_FAIL_D3D12_RELEASE_KEYED_MUTEX_TO_OWN,
    STC_MESSAGE_ID_SERVER_D3D11_CREATE_FRAME_ATTEMPT,
    STC_MESSAGE_ID_SERVER_FAIL_D3D11_USER_CREATE_FRAME_CALLBACK,
    STC_MESSAGE_ID_SERVER_D3D11_CREATE_FRAME_SUCCESS,
    STC_MESSAGE_ID_SERVER_D3D12_CREATE_FRAME_ATTEMPT,
    STC_MESSAGE_ID_SERVER_FAIL_D3D12_USER_CREATE_FRAME_CALLBACK,
    STC_MESSAGE_ID_SERVER_D3D12_CREATE_FRAME_SUCCESS,
    STC_MESSAGE_ID_SERVER_FAIL_D3D11_ACQUIRE_KEYED_MUTEX_TO_WRITE,
    STC_MESSAGE_ID_SERVER_FAIL_D3D11_QUEUE_WAIT,
    STC_MESSAGE_ID_SERVER_FAIL_D3D12_ACQUIRE_KEYED_MUTEX_TO_WRITE,
    STC_MESSAGE_ID_SERVER_FAIL_D3D12_QUEUE_WAIT,
    STC_MESSAGE_ID_SERVER_FAIL_D3D11_RELEASE_KEYED_MUTEX_TO_WRITE,
    STC_MESSAGE_ID_SERVER_FAIL_D3D11_QUEUE_SIGNAL,
    STC_MESSAGE_ID_SERVER_FAIL_D3D12_RELEASE_KEYED_MUTEX_TO_WRITE,
    STC_MESSAGE_ID_SERVER_FAIL_D3D12_QUEUE_SIGNAL,
    STC_MESSAGE_ID_CLIENT_VERSION,
    STC_MESSAGE_ID_CLIENT_CREATE_D3D11_SUCCESS,
    STC_MESSAGE_ID_CLIENT_CREATE_D3D12_SUCCESS,
    STC_MESSAGE_ID_CLIENT_DESTROY_D3D11_SUCCESS,
    STC_MESSAGE_ID_CLIENT_DESTROY_D3D12_SUCCESS,
    STC_MESSAGE_ID_CLIENT_D3D11_OPEN_FRAME_ATTEMPT,
    STC_MESSAGE_ID_CLIENT_FAIL_D3D11_USER_OPEN_FRAME_CALLBACK,
    STC_MESSAGE_ID_CLIENT_D3D11_OPEN_FRAME_SUCCESS,
    STC_MESSAGE_ID_CLIENT_D3D12_OPEN_FRAME_ATTEMPT,
    STC_MESSAGE_ID_CLIENT_FAIL_D3D12_USER_OPEN_FRAME_CALLBACK,
    STC_MESSAGE_ID_CLIENT_D3D12_OPEN_FRAME_SUCCESS,
} StcMessageId;

typedef bool (*PFN_StcCreateFunctionD3D11)(void* pUserData, size_t index, ID3D11Texture2D* pTexture);
typedef void (*PFN_StcDestroyFunctionD3D11)(void* pUserData, size_t index);

typedef bool (*PFN_StcCreateFunctionD3D12)(void* pUserData, size_t index, ID3D12Resource* pTexture);
typedef void (*PFN_StcDestroyFunctionD3D12)(void* pUserData, size_t index);

typedef void (*PFN_StcMessageFunction)(StcMessageCategory category, StcMessageSeverity severity, StcMessageId id,
                                       const char* descripiton, void* pUserData);

typedef struct StcD3D11AllocationCallbacks {
    void* pUserData;
    PFN_StcCreateFunctionD3D11 pfnCreate;
    PFN_StcDestroyFunctionD3D11 pfnDestroy;
} StcD3D11AllocationCallbacks;

typedef struct StcD3D12AllocationCallbacks {
    void* pUserData;
    PFN_StcCreateFunctionD3D12 pfnCreate;
    PFN_StcDestroyFunctionD3D12 pfnDestroy;
} StcD3D12AllocationCallbacks;

typedef struct StcMessageCallbacks {
    void* pUserData;
    PFN_StcMessageFunction pfnMessage;
} StcMessageCallbacks;

typedef struct StcAtomicBool {
    volatile CHAR storage;
} StcAtomicBool;

static inline bool StcAtomicBoolLoad(const StcAtomicBool* const pA) {
    const CHAR bytes = pA->storage;
    _ReadWriteBarrier();
    return (bool)bytes;
}

static inline void StcAtomicBoolStore(StcAtomicBool* const pA, const bool value) {
    _InterlockedExchange8(&pA->storage, (CHAR)value);
}

typedef struct StcAtomicUint32 {
    volatile LONG storage;
} StcAtomicUint32;

static inline uint32_t StcAtomicUint32Load(const StcAtomicUint32* const pA) {
    const LONG bytes = pA->storage;
    _ReadWriteBarrier();
    return (uint32_t)bytes;
}

static inline void StcAtomicUint32StoreRelaxed(StcAtomicUint32* const pA, const uint32_t value) { pA->storage = (LONG)value; }

static inline void StcAtomicUint32Store(StcAtomicUint32* const pA, const uint32_t value) {
    _InterlockedExchange(&pA->storage, (LONG)value);
}

static inline uint32_t StcAtomicUint32Increment(StcAtomicUint32* const pA) { return (uint32_t)_InterlockedIncrement(&pA->storage); }

static inline uint32_t StcAtomicUint32Decrement(StcAtomicUint32* const pA) { return (uint32_t)_InterlockedDecrement(&pA->storage); }

typedef struct StcAtomicInt64 {
    __declspec(align(8)) volatile LONG64 storage;
} StcAtomicInt64;

static inline int64_t StcAtomicInt64Load(const StcAtomicInt64* const pA) {
#ifdef _M_IX86
    const long long bytes = __iso_volatile_load64(&pA->storage);
#else
    const LONG64 bytes = pA->storage;
#endif
    _ReadWriteBarrier();
    return bytes;
}

static inline void StcAtomicInt64StoreRelaxed(StcAtomicInt64* const pA, const int64_t value) { pA->storage = value; }

static inline void StcAtomicInt64Store(StcAtomicInt64* const pA, const int64_t value) {
#ifdef _M_IX86
    const LONG64 comparand = StcAtomicInt64Load(pA);
    const LONG64 exchange = value;
    LONG64 result;
    do {
        result = _InterlockedCompareExchange64(&pA->storage, exchange, comparand);
    } while (result != comparand);
#else
    _InterlockedExchange64(&pA->storage, value);
#endif
}

static inline int64_t StcAtomicInt64CompareExchange(StcAtomicInt64* const pA, const int64_t exchange, const int64_t comparand) {
    return _InterlockedCompareExchange64(&pA->storage, exchange, comparand);
}

#define STC_MAJOR_VERSION 0
#define STC_MINOR_VERSION 1
#define STC_PATCH_VERSION 0

// One 4K page is probably reasonable
#define STC_MAP_SIZE 4096

// Four slots should prevent stuttering
#define STC_TEXTURE_COUNT 4

#define STC_DEFAULT_PREFIX TEXT("StcGC")

#pragma warning(push)
#pragma warning(disable : 4820)

typedef struct StcGlobalInfo {
    int version;
    StcApi serverApi;
    StcAtomicInt64 connectToken;
} StcGlobalInfo;

static_assert(sizeof(StcGlobalInfo) < STC_MAP_SIZE, "Shared memory size is out of control");

typedef struct StcInfo {
    // Client Connect intialized
    StcBindFlags clientBindFlags;
    StcSrgbChannelType srgbChannelType;
    StcApi clientApi;
    StcAtomicBool clientParametersSpecified;

    // Server Tick initialized
    uint32_t hTextures[STC_TEXTURE_COUNT];
    uint32_t hWriteFences12[STC_TEXTURE_COUNT];
    uint32_t hReadFences12[STC_TEXTURE_COUNT];
    UINT64 writeFenceValues12[STC_TEXTURE_COUNT];
    UINT64 readFenceValues12[STC_TEXTURE_COUNT];
    bool invalidated[STC_TEXTURE_COUNT];

    // Server MakeConnection initialized
    StcAtomicUint32 pendingWrites;
    StcAtomicUint32 pendingReads;
    StcAtomicInt64 serverKeepAlive;

    // Server Tick initialized
    StcAtomicBool serverInitialized;
    StcAtomicUint32 serverStopReason;

    // Client Connect/Tick initialized
    StcAtomicInt64 clientKeepAlive;

    // Client Disconnect initialized
    StcAtomicUint32 clientStopReason;
} StcInfo;

static_assert(sizeof(StcInfo) < STC_MAP_SIZE, "Shared memory size is out of control");

#pragma warning(pop)

#ifdef __cplusplus
}
#endif
